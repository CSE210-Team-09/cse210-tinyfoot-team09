# Bigfoot Code Review

## Design Decisions:

The source code is found inside the coffee and scss folders and it uses Grunt to compile them into Javascript and CSS files for distribution. However, there are further dependencies. This version of Grunt uses Ruby and Sass to run. We noticed that the README does not go into further detail about the dependencies and assumes users are familiar with them or already have these installed. These design decisions don’t follow the UX > DX philosophy that says “developer preferences matter, but if they affect users negatively that's on the developer not the technology!” Bigfoot’s creator uses CoffeeScript and SCSS and runs Grunt to automatically compile them into Javascript and CSS for release. However due to the extra dependencies that aren’t even well documented, this process makes it extremely hard for users to actually change the functionality of Bigfoot. 

Instead of prioritizing the user, these design decisions make it harder for the user to adopt Bigfoot. As a software developer/engineer, the quality of software is directly impacted by the accessibility and ease of use. When it is easier to download and use, more people will cite that as a reason to use your software over other competitors. Moreover, the use of many dependencies also goes against the principle that minimalism is the optimal practice to follow. Minimalism means less and less means sustainability and easier maintainability. Another notable design decision is that the only function inside the coffee folder is programmed as an IIFE (immediately invoked function expression). This could be considered a smart move because it won’t pollute the global namespace. 

## Code Organization and Quality:

The code is all organized into one long file and as one big function within that file. The bigfoot.coffee file inside the coffee folder, inside the src folder is where the bulk of Bigfoot lies. This is hard for someone who wants to test components of the coffee file. Additionally, it’s daunting for developers new to the technology to change the behaviors — going through several hundred lines is a difficult task to do. This means that if an individual different than the one that originally worked on Bigfoot was working on it, it would take a long time of combing through the code to find what they are looking for and test for it. Conversely, if it were split into chunks of code that were more easily testable and identifiable, it would be easier to address the issue of readability and testability. That said, the coffee file itself is well documented and each function’s purpose is clear and even inline comments, and a more experienced web developer can more easily pick up where the project is and work on it. 

Another portion of the code is organized in its own dist folder, outside of the src folder, with a lot of the styling components. This is a very common practice for web development projects, that is almost mandated at this point. However, the major takeaway regarding the code organization is that it could have been modularized into smaller chunks of code, allowing for easier testing of all the functions inside the folder. The basic idea is that code of a higher quality is more understandable and easier to be built upon. Quality here can be defined as more specific functions and testing of these functions. The Bigfoot codebase does neither of these and therefore loses points in the quality of code analysis.

## Repository Organization and Quality:

The organization of the repository is fairly straightforward with two main folders that contain the majority of code as well as styling choices. The dist folder contains the code used for production regarding the web application interface. This includes the CSS files, which are files concerned with webpage styling. It also has the Bigfoot.js file. The dist folder contains the minimized version of the source code that is used in a production environment. The other major folder is the src folder which has two subfolders. These are the coffee and scss folders. The scss folder is again concerned with more styling choices such as buttons and pop-ups. Additionally, there are a few other files in the main repository but the notable one of those seems to be Gruntfile.coffee. This seems to be a dependency that is used towards compiling the source code. The repository also has a README file that describes the main purpose of Bigfoot but does not explain the dependencies or how to get it to run on your local system. It would have been much better documented if the README file clearly explained how to use Bigfoot in addition to what it does. The use of package.json and package-lock json makes easier for users to npm install the needed node dependencies (but not all of them like ruby and sass). Additional project dependencies are also specified in bower.json, such as jQuery version. Overall, the Bigfoot repository is well organized and there aren’t too many aspects that we would change without touching the organization of the code itself. We feel that improving the README file would also heavily benefit the code repository quality as it would point the user or developer in the right direction. It’s also interesting to note that the bower.json specifies “test” and “tests” directory from being included in the bower distribution. This likely means that there were tests that the developer used during the development of bigfoot but decided to not include it during the release for some reason. 

## Tool Quality:

Bigfoot uses quite a few tools and technologies within the code to successfully create the footnotes. Bigfoot is built as a jQuery plugin and this is a choice that was made rather than using native JavaScript. This decision was probably made to reduce the development time and also due to the fact that jQuery provides simpler syntax than native. jQuery is a very widely used tool for web development and is of good quality. 

Coffeescript is also another tool used in this codebase to compile a more concise syntax into JavaScript. It increases the readability compared to regular JavaScript by emulating Python with its minimal syntax. The main benefit of Coffeescript is that with its minimal syntax, it makes a more readable source code and therefore easier to debug and update. Although, Coffeescript is starting to decline in popularity due to JavaScript improving itself by incorporating the benefits of Coffeescript. Along with this development, Typescript is also gaining momentum due to static typing and advanced type checking. Another observation regarding Coffeescript is that most of the user oriented settings are in the .coffee file in a dictionary, but these should just be placed within the settings file with constants that reads these settings when Bigfoot is running. In a better implementation, entering the dev environment should not be needed just to select one of the preset behaviors (ex. changing batch sizes).

SCSS is a superset of CSS and therefore contains many similarities. The S stands for sassy and is a little more complex than regular CSS. It introduces more programming-like features as compared to regular CSS. SCSS also allows you to create custom functions and is better about readability. One example is that SCSS allows you to style in HTML format. However, for this specific project, SCSS might not have been necessary because the footnote is simply converted into a clickable button, and then replaced with a rectangle popover afterwards. The code is split in a modular way in terms of main components and does use some custom properties, though, it is not until much later in the code. Some might think that SCSS was unnecessary for this codebase and complicated it, but it is not a negative tool decision made by the developers. 

In Bigfoot, there are many simple changes that can be done to the footnotes, such as changing from on click to on hover and simple visual changes like color of the footnote buttons. However, for any of these changes to take place, grunt needs to be ran in order for the corresponding changes in .coffee and .scss to take place, even though they might just be changing truth values or RGB values. This means that the user must install ruby and sass and all other dependencies for even the tiniest of changes. A better development environment could be one where these easy preset files are stored in some configuration file like JSON, and the dist/js or CSS file will then read these constants to determine the behavior of the web page. This makes it so that one does not have to enter the development environment when they are just making simple changes that is basically pre-defined. For feasibility of user development, only larger functional changes should require the need to enter the development environment. 

Bigfoot also uses non-semantic HTML where it uses regex to find footnotes within the DOM by looking in href. It then replaces the element with a giant non-semantic HTML div “big-footnote_container.” Another decision made was to use the alt attribute for accessibility, which is a net positive for Bigfoot. However, the wrapper for the button is too complicated within the CSS file. There are multiple variations of a function along the lines of “bigfoot-footnote_button”

## Other Relevant Information:

Some other information that we felt should be included in this writeup is that there is no documentation of any kind, whether in formal documentation or comments in the distributive section format. We were able to kind of figure out its purpose through the internet and learning online, but it could have been better documented. This lack of documentation includes how to even run bigfoot and what tags make footnotes turn into footnotes that bigfoot.js recognizes. 

Additionally, another major aspect that we thought was important to highlight is that there are no test cases or CI/CD practice. This obviously makes it harder to test the basic use cases of Bigfoot, but also to test any changes we were to make. A compliment we had for the developers of Bigfoot, however, was the regular use of comments within the Bigfoot.coffee file within the src folder. There was documentation in the form of comments, and this was recurring within the functions every couple of lines to outline the intentions. 

## Would we use it?

After examining the repository and working with Bigfoot, we see that if one just wants to use the existing functionality of bigfoot without any changes, they can easily do so by just using the files in the dist folder. However, it takes a considerable amount of effort to actually work on Bigfoot from a development standpoint. Even with the smallest changes, the entire development setup process is just overwhelming. In fact, it’s probably more likely that getting the additional dependencies that bigfoot requires to work properly on your computer is much harder than actually changing the function behavior within the .coffee file itself since it’s so well documented. As a result, we wouldn’t use it due to the difficulties of setting up the environment and the learning curve of each of the tools being used. 

We can mitigate these development issues by working with just javascript and CSS functionalities (since ultimately coffeescript and scss translates into these).

## Demo - color change and hover

### [Video Link](CSE_210_Team_9_Bigfoot_Demo.mp4)

The demo video shows the basic version of Bigfoot and how it works with a simple html file. Then a minor color change to the background of the footnote popover is made in the source file. It is also changed to work on hover instead of on click. We then show that the html page reflects these changes.

### [Repo Link](https://github.com/CSE210-Team-09/bigfoot)

The above link goes to the Github repository where we made our small change to Bigfoot for part 1 of the warmup, that can be seen reflected in the demo video.